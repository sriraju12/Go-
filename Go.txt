GO:

Go is a open source programming language.

* We define a main package to run the program.

* We import the fmt package to help us print to the console.

* The main function is the starting point of execution, and inside it, we call fmt.Println() to print
  "Hello, World!" to the screen.

Example:

package main

import "fmt"

func main() {
	fmt.Println("hello world")
}

  NOTE:
  you can not use single quotes for print the values in fmt. use only double quotes or back ticks(`)

  Module:
  A module is essentially a collection of Go packages that are versioned together.

  Key Files:
  
  * go.mod: This file defines the module and its dependencies. It's automatically created when you initialize a 
            Go module with the go mod init command.

  * go.sum: This file contains cryptographic hashes for the dependencies listed in go.mod to ensure that the
            dependencies haven’t been tampered with.

  How to Use Go Modules:

  1.Initialize a Go Module:
    
    To create a new module for your Go project, navigate to your project directory and run:
     
       -> go mod init <module-name>

      * <module-name> is typically the name of your module or the repository URL if you're planning to publish it.

      * This will generate a go.mod file in your project directory.


  2.Adding Dependencies:

    To add a new dependency (for example, a package from a remote repository), you can simply import it in
    your code and run:

       -> go get <dependency-path>

       * Go will automatically update the go.mod file to include this dependency, and it will also update
         the go.sum file to add cryptographic hashes for verification.

  3.Building the Project:
   
    Once you've initialized the module and added dependencies, you can build your project as usual:

       -> go build
    
       * This will use the dependencies defined in go.mod to build your project.

Basic Data Types:

1.Integer types:
                Used for whole numbers (without decimals)

                Example:
                         var amount = 1000 or var amount int = 1000

2.Floating-point types:
                       Used for numbers with decimal points.   

                       Example:
                                var amount = 1000.0 or var amount float64 = 1000.0

3.Boolean Type:
                Represents a Boolean value, which can be true or false.

                Example:
                        var isGoFun = true  or  var isGoFun bool = true

4.String Type:
              Represents a sequence of characters (text). Strings in Go are immutable, meaning their contents
              can't be changed once created.

              Example:
                     var greeting = "Hello, Go!" or var greeting string = "Hello, Go!"


Example:

package main

import (
	"fmt"
	"math"
)

func main() {

	var investmentAmount = 1000
	var expectedReturn = 5.5
	var years = 10
	var totalAmount = float64(investmentAmount) * math.Pow(1+expectedReturn/100, float64(years))

	fmt.Println("Toatal Amount: $", totalAmount)
}



Null Values:

 * All Go value types come with a so-called "null value" which is the value stored in a variable if no other value
   is explicitly set.

   Here's a list of the null values for the different types:

    * int => 0

    * float64 => 0.0

    * string => "" (i.e., an empty string)

    * bool => false    

NOTE:

* go run name_of_file to run the go application, which is used for development purpose only not for production.

* in your project, if module is present then you can run the application using go run .

* for converting int into float64 then you can use -> float64(int_value)


Explicit Type Convertion(Type Assignment):
                        
 * var amount float64 = 1000, here it can store int and float values.                         

package main

import (
	"fmt"
	"math"
)

func main() {

	var investmentAmount float64 = 1000
	var expectedReturn = 5.5
	var years float64 = 10
	
    var totalAmount = investmentAmount * math.Pow(1+expectedReturn/100, years)

	fmt.Println("Toatal Amount: $", totalAmount)
}

Alternative Variable Declaration style:

 * instead declaring variable with var, simple you can do this for declaring and Assigning a value.

   Example: amount := 1000 # it will automatically takes it's type based on the value.

 * you can declare multiple values in a single line.

   Example: amount, years := 1000,5  

 * if that variable needs to be a particular type then you can use this.

   Example: amount, years float64 = 1000.0, 5.0 or 1000, 5.5  

 * we can also declare like this, for two different types.

   Example: investmentAmount, years  := 1000, 5.5


const variable:

 * it is Immutable Once assigned, the value of a constant cannot be modified.

   Example: const amount = 1000


Difference Between var and const:

var:

  * Mutable: A variable declared with var can be changed during the program's execution. You can assign a 
             new value to it after it is initialized.

  * Memory: Variables are stored in memory and can be modified.

const:

  * Immutable: A constant declared with const is a value that cannot be changed once set. It is fixed at 
               compile time.

  * Memory: Constants do not occupy memory during execution because their values are directly embedded into
            the program at compile time. 


User Input:

  * reads space-separated input from the user. It takes one or more arguments, which it assigns values to.

    Example:

     var age int  # when taking input from user, we need to explicitly mention the type of variable.

     fmt.Println("Enter age: ")
     fmt.Scan(&age)  #  here & is used to pass a pointer to the variable

fmt.Scan() Limitations:

  * The fmt.Scan() function is a great function for easily fetching & using user input through the command line.

  * But this function also has an important limitation: You can't (easily) fetch multi-word input values.
    Fetching text that consists of more than a single word is tricky with this function.


Example using above concepts:

package main

import (
	"fmt"
	)
	
func main() {

	var revenue float64
	var expenses float64
	var taxRate float64

	fmt.Println("Enter the revenue:")
	fmt.Scan(&revenue)
	fmt.Println("Enter the expenses:")
	fmt.Scan(&expenses)
	fmt.Println("Enter the tax rate (as decimal):") 
	fmt.Scan(&taxRate)

	earningsBeforeTax := revenue - expenses
	earningsAfterTax := earningsBeforeTax * (1 - taxRate/100)

	fmt.Println("Earnings before tax:", earningsBeforeTax)
	fmt.Println("Earnings after tax:", earningsAfterTax)

}

we can also output the values using Printf(print format):

  * %v is used to print the text.

  * %.2f is used to print the value to 2 decimal values

package main

import (
	"fmt"
	)
	
func main() {

	var revenue float64
	var expenses float64
	var taxRate float64

	fmt.Println("Enter the revenue:")
	fmt.Scan(&revenue)
	fmt.Println("Enter the expenses:")
	fmt.Scan(&expenses)
	fmt.Println("Enter the tax rate (as decimal):") 
	fmt.Scan(&taxRate)

	earningsBeforeTax := revenue - expenses
	earningsAfterTax := earningsBeforeTax * (1 - taxRate/100)

	// fmt.Printf("Earnings before tax:", earningsBeforeTax)
	fmt.Printf("Earnings before tax: %v\nEarnings after tax: %v", earningsBeforeTax, earningsAfterTax)

    // if want to print only 2 decimal value.
    fmt.Printf("Earnings before tax: %.2f\nEarnings after tax: %.2f", earningsBeforeTax, earningsAfterTax)

}

formatted string:

    * fmt.Sprintf is used to format(store) data into a string and return it.

    * It doesn’t print the output but gives you a formatted string that you can use elsewhere.

    Example:

     age := 26

     result := fmt.Sprintf("My age is: %d", age)
     fmt.Println(result)

     for above example,

     ebt := fmt.Sprintf("Earnings before tax: %.2f",earningsBeforeTax)
     eat := fmt.Sprintf("Earnings after tax: %.2f",earningsAfterTax)

     fmt.Println(ebt)
     fmt.Println(eat)


Multiline Strings:

  * A raw string literal is enclosed in backticks ( `). It preserves line breaks, special characters, and 
    whitespace exactly as they appear between the backticks.

  Example:

        str := `This is a 
        multiline string
        in Go.
        No need for escape characters like \n or \t.`
            
        fmt.Println(str)

        Output:

        This is a 
        multiline string
        in Go.
        No need for escape characters like \n or \t.


Functions:

  * functions are blocks of code that perform a specific task. Functions allow you to organize your code, 
    make it reusable, and simplify complex programs. A function in Go can take input, perform operations,
    and return a result.

    syntax: for simple function with parameter

             func outputText(text string) {  # defining function
                fmt.Println(text)
             }

             calling a function ->  outputText("hello raju")


    syntax: Function with Return Value

             func add(a int, b int) int {
                return a + b
             }  

             calling a function ->  result := add(2,3) 

    syntax: Function with Multiple Return Values

             func calculate(a int, b int) (int, int) {   # here (int, int) is function return value type.
                sum := a + b
                diff := a - b
                return sum, diff
            }

              calling a function ->  sum, diff := calculate(5,3)


    syntax: Alternative Function with Multiple Return Values

              func calculate(a int, b int) (sum int, diff int) {   # here (sum int, diff int) is function return value type with this name.
                sum = a + b
                diff = a - b
                return or  return sum, diff
            }

              calling a function ->  sum, diff := calculate(5,3)


Example:

package main

import (
	"fmt"
)

func main() {

	revenue := userInputText("Enter the revenue:")
	expenses := userInputText("Enter the expenses:")
	taxRate := userInputText("Enter the tax rate (as decimal):")

	earningsBeforeTax, earningsAfterTax  := calculateEarnings(revenue, expenses, taxRate)

    fmt.Printf("Earnings before tax: %.2f\nEarnings after tax: %.2f", earningsBeforeTax, earningsAfterTax)


}

func calculateEarnings(revenue, expenses, taxRate float64) (float64, float64) {
	earningsBeforeTax := revenue - expenses
	earningsAfterTax := earningsBeforeTax * (1 - taxRate/100)
	return earningsBeforeTax, earningsAfterTax
}

func userInputText(text string) float64 {
    var userInput float64

 	fmt.Println(text)
	fmt.Scan(&userInput)
	
	return userInput
}

Anonymous functions:

	* anonymous functions are functions defined without a name. They are useful when you want to define a 
	  function inline, especially for short operations like goroutines, callbacks, or closures.

	  syntax: func() {
				fmt.Println("Hello from an anonymous function!")
			}

	  Assign anonymous function to a variable:

	    package main

		import (
			"fmt"
		)

		func main() {

			greet := func(name string) {
				fmt.Println("Hello", name)
			}
			// Call the function using the variable
			greet("raju")
		}	


Recursion:
           calling the function again and again.

Example: factorial of a number without recursion.

package main

import (
	"fmt"
)

func main() {

	result := factorial(6)

	fmt.Println(result)
}

func factorial(num int) int {
	result := 1

	for i := 1; i <= num; i++ {
		result = result * i
	}
	return result
}


using recursion:

package main

import (
	"fmt"
)

func main() {

	result := factorial(6)

	fmt.Println(result)
}

func factorial(num int) int {
	if num == 0 {
		return 1   # when num is 0 then it will stop execution, if you don't provide this condition then it will go into infinite loop
	}
	return num * factorial(num - 1)  # here calling the function again and again. 
}


Variadic Function:
				  A variadic function is a function that can take a variable number of arguments of the same type.
				  Super handy when you don’t know exactly how many inputs you’ll need ahead of time.

				  syntax: ...type i.e ...int

Example: here you can pass any number of values, it will return sum of their values.

package main

import (
	"fmt"
)

func main() {

	result := sumOfNumbers(1,2,3,4,5,6,7,8)

	fmt.Println(result)
}

func sumOfNumbers(num ...int) int {
	sum := 0

	for _, val := range num {
		sum += val
	}
	return sum
}


if you want to pass array or slices to variadic then use this,

package main

import (
	"fmt"
)

func main() {

	numbers := []int{1,2,3,4,5,6,7,8}

	result := sumOfNumbers(numbers...) # here it will extract one one value from numbers

	fmt.Println(result)
}

func sumOfNumbers(num ...int) int {
	sum := 0

	for _, val := range num {
		sum += val
	}
	return sum
}




Control Statements:
                   control statements allow you to make decisions or repeat actions

  if:
     The if statement is used to execute a block of code based on a condition.

  else:
       You can extend if with an else block to provide an alternative path when the condition is false.

  else if:
        This allows you to test multiple conditions sequentially.

Example:  

package main

import (
	"fmt"
)

func main() {

  var accountBalance float64 = 1000.00

  fmt.Println("Welcome to the Bank!")
  fmt.Println("What do you want to do?")
  fmt.Println("1. Check balance")
  fmt.Println("2. Deposit money")
  fmt.Println("3. Withdraw money")
  fmt.Println("4. Exit")

  var choice int
  fmt.Println("Enter your choice:")
  fmt.Scanln(&choice)

 // wantsCheckBalance := choice == 1

  if choice == 1 {
  fmt.Println("Your balance is:", accountBalance)
  } else if choice == 2 {
	var depositAmount float64
	fmt.Println("Enter the amount to deposit:")
	fmt.Scanln(&depositAmount)
    if depositAmount <= 0 {
        fmt.Println("Please Deposit amount greater than 0")
		return
    }
	accountBalance += depositAmount
	fmt.Println("Your updated balance is:", accountBalance)
} else if choice == 3 {
	var withdrawAmount float64
	fmt.Println("Enter the amount to withdraw:")
	fmt.Scanln(&withdrawAmount)
    if withdrawAmount <= 0  || withdrawAmount > accountBalance {
        fmt.Println("Please withdraw amount greater than 0 and less than or equal to your balance")
		return
    } else {
		accountBalance -= withdrawAmount
		fmt.Println("Your updated balance is:", accountBalance)
	}
} else if choice == 4 {
	fmt.Println("Thank you for using the Bank!")
} else {
	fmt.Println("Invalid choice!")
}

}


Loops:
      The for loop is the only loop in Go

      * Basic for loop:
        
        package main
        import "fmt"

        func main() {
            for i := 1; i <= 5; i++ {
                fmt.Println(i)
            }
        }

      * infinite loop:

         package main

         import "fmt"

         func main() {

            for {
                fmt.Println("Welcome to the Bank!")
            }

         }

break:
      Used to exit from a for loop or switch statement.  

      syntax: break 

      Example:

      package main
      import "fmt"

      func main() {
        for i := 1; i <= 5; i++ {
            if i == 3 {
                break // Exits the loop when i equals 3
            }
            fmt.Println(i)
            }
        }


continue:
         Used to skip the current iteration of the loop and move to the next iteration.

         syntax: continue

         Example:

         package main
         import "fmt"
 
         func main() {
             for i := 1; i <= 5; i++ {
                 if i == 3 {
                     continue // Skips printing 3
                 }
                 fmt.Println(i)
             }
         }


Example using conditional statements:

package main

import (
	"fmt"
)

func main() {

  var accountBalance float64 = 1000.00

  fmt.Println("Welcome to the Bank!")

  for {

  fmt.Println("What do you want to do?")
  fmt.Println("1. Check balance")
  fmt.Println("2. Deposit money")
  fmt.Println("3. Withdraw money")
  fmt.Println("4. Exit")

  var choice int
  fmt.Println("Enter your choice:")
  fmt.Scanln(&choice)

 // wantsCheckBalance := choice == 1

  if choice == 1 {
  fmt.Println("Your balance is:", accountBalance)
  } else if choice == 2 {
	var depositAmount float64
	fmt.Println("Enter the amount to deposit:")
	fmt.Scanln(&depositAmount)
    if depositAmount <= 0 {
        fmt.Println("Please Deposit amount greater than 0")
		continue
    }
	accountBalance += depositAmount
	fmt.Println("Your updated balance is:", accountBalance)
} else if choice == 3 {
	var withdrawAmount float64
	fmt.Println("Enter the amount to withdraw:")
	fmt.Scanln(&withdrawAmount)
    if withdrawAmount <= 0  || withdrawAmount > accountBalance {
        fmt.Println("Please withdraw amount greater than 0 and less than or equal to your balance")
		continue
    } else {
		accountBalance -= withdrawAmount
		fmt.Println("Your updated balance is:", accountBalance)
	}
} else if choice == 4 {
	fmt.Println("Thank you for using the Bank!")
	break
} else {
	fmt.Println("Invalid choice!")
}

}

}

Switch:
       The switch statement is used to handle multiple possible conditions for a variable. It's an alternative 
       to using multiple if-else statements.

Example:
package main

import (
	"fmt"
)

func main() {

  var accountBalance float64 = 1000.00

  fmt.Println("Welcome to the Bank!")

  for {

  fmt.Println("What do you want to do?")
  fmt.Println("1. Check balance")
  fmt.Println("2. Deposit money")
  fmt.Println("3. Withdraw money")
  fmt.Println("4. Exit")

  var choice int
  fmt.Println("Enter your choice:")
  fmt.Scanln(&choice)

 // wantsCheckBalance := choice == 1

 switch choice {
	 case 1:
		fmt.Println("Your balance is:", accountBalance)
	
	 case 2:
		var depositAmount float64
		fmt.Println("Enter the amount to deposit:")
		fmt.Scanln(&depositAmount)
		if depositAmount <= 0 {
			fmt.Println("Please Deposit amount greater than 0")
			continue
		}
		accountBalance += depositAmount
		fmt.Println("Your updated balance is:", accountBalance)

	 case 3:
		var withdrawAmount float64
		fmt.Println("Enter the amount to withdraw:")
		fmt.Scanln(&withdrawAmount)
		if withdrawAmount <= 0  || withdrawAmount > accountBalance {
			fmt.Println("Please withdraw amount greater than 0 and less than or equal to your balance")
			continue
		} else {
			accountBalance -= withdrawAmount
			fmt.Println("Your updated balance is:", accountBalance)
		}

	 case 4:
		fmt.Println("Thank you for using the Bank!")	
		return
	 default:
		fmt.Println("Invalid choice!")

    }
  }
}


File Handling:

1. writing to a file:
   
     * adding some content to a file

     Example:  # here the balance amount is added to text file

package main

import (
	"fmt"
	"os"
    "strconv"
)

func writeBalanceToFile(balance float64) {
	balanceText := fmt.Sprintf("%v",balance)
	os.WriteFile("balance.txt", []byte(balanceText), 0644)
}

func readBalanceFromFile() float64 { 
	data, _ := os.ReadFile("balance.txt")  // here _ is used to ignore the error
  	balanceText := string(data)
	balance, _ := strconv.ParseFloat(balanceText, 64)
	return balance
}

func main() {

  var accountBalance float64 = readBalanceFromFile()

  fmt.Println("Welcome to the Bank!")

  for {

  fmt.Println("What do you want to do?")
  fmt.Println("1. Check balance")
  fmt.Println("2. Deposit money")
  fmt.Println("3. Withdraw money")
  fmt.Println("4. Exit")

  var choice int
  fmt.Println("Enter your choice:")
  fmt.Scanln(&choice)

 // wantsCheckBalance := choice == 1

 switch choice {
	 case 1:
		fmt.Println("Your balance is:", accountBalance)
	
	 case 2:
		var depositAmount float64
		fmt.Println("Enter the amount to deposit:")
		fmt.Scanln(&depositAmount)
		if depositAmount <= 0 {
			fmt.Println("Please Deposit amount greater than 0")
			continue
		}
		accountBalance += depositAmount
		fmt.Println("Your updated balance is:", accountBalance)
		writeBalanceToFile(accountBalance)

	 case 3:
		var withdrawAmount float64
		fmt.Println("Enter the amount to withdraw:")
		fmt.Scanln(&withdrawAmount)
		if withdrawAmount <= 0  || withdrawAmount > accountBalance {
			fmt.Println("Please withdraw amount greater than 0 and less than or equal to your balance")
			continue
		} else {
			accountBalance -= withdrawAmount
			fmt.Println("Your updated balance is:", accountBalance)
			writeBalanceToFile(accountBalance)
		}

	 case 4:
		fmt.Println("Thank you for using the Bank!")	
		return
	 default:
		fmt.Println("Invalid choice!")

    }
  }
}

2.reading data from a file:

Example: here amount balancing is reading from a file

import (
	"fmt"
	"os"
	"strconv"
)

func writeBalanceToFile(balance float64) {
	balanceText := fmt.Sprintf("%v",balance)
	os.WriteFile("balance.txt", []byte(balanceText), 0644)
}

func readBalanceFromFile() float64 { 
	data, _ := os.ReadFile("balance.txt")  // here _ is used to ignore the error
  	balanceText := string(data)
	balance, _ := strconv.ParseFloat(balanceText, 64)
	return balance
}

func main() {

  var accountBalance float64 = readBalanceFromFile()

  fmt.Println("Welcome to the Bank!")

  for {

  fmt.Println("What do you want to do?")
  fmt.Println("1. Check balance")
  fmt.Println("2. Deposit money")
  fmt.Println("3. Withdraw money")
  fmt.Println("4. Exit")

  var choice int
  fmt.Println("Enter your choice:")
  fmt.Scanln(&choice)

 // wantsCheckBalance := choice == 1

 switch choice {
	 case 1:
		fmt.Println("Your balance is:", accountBalance)
	
	 case 2:
		var depositAmount float64
		fmt.Println("Enter the amount to deposit:")
		fmt.Scanln(&depositAmount)
		if depositAmount <= 0 {
			fmt.Println("Please Deposit amount greater than 0")
			continue
		}
		accountBalance += depositAmount
		fmt.Println("Your updated balance is:", accountBalance)
		writeBalanceToFile(accountBalance)

	 case 3:
		var withdrawAmount float64
		fmt.Println("Enter the amount to withdraw:")
		fmt.Scanln(&withdrawAmount)
		if withdrawAmount <= 0  || withdrawAmount > accountBalance {
			fmt.Println("Please withdraw amount greater than 0 and less than or equal to your balance")
			continue
		} else {
			accountBalance -= withdrawAmount
			fmt.Println("Your updated balance is:", accountBalance)
			writeBalanceToFile(accountBalance)
		}

	 case 4:
		fmt.Println("Thank you for using the Bank!")	
		return
	 default:
		fmt.Println("Invalid choice!")

    }
  }
}

3.Handling errors:

    * Handling errors in file handling like if there is no file exists then it throw error that we need catch.

    * here we are using bulit-in error using if err != nil and also we are using custom errors using errors.new()

    * here we are checking, if the balance is file not present then we are adding some balance to a file and also
      throwing error message.

Example:

package main

import (
	"errors"
	"fmt"
	"os"
	"strconv"
)

func writeBalanceToFile(balance float64) {
	balanceText := fmt.Sprintf("%v", balance)
	os.WriteFile("balance.txt", []byte(balanceText), 0644)
}

func readBalanceFromFile() (float64, error) {
	data, err := os.ReadFile("balance.txt")

	if err != nil {
		return 1000, errors.New("file not found, creating a new file with default balance of 1000")
	}
	balanceText := string(data) // convert byte array to string
	balance, err := strconv.ParseFloat(balanceText, 64)

	if err != nil {
		return 1000, errors.New("error parsing balance from file")
	}

	return balance, nil // here nil is used to indicate that there is no error
}

func main() {

	var accountBalance, err = readBalanceFromFile()

	if err != nil {
		fmt.Println("ERROR:", err)
		fmt.Println("Creating a new file with default balance of 1000")
        fmt.println("#######################################################")
	}

	fmt.Println("Welcome to the Bank!")

	for {

		fmt.Println("What do you want to do?")
		fmt.Println("1. Check balance")
		fmt.Println("2. Deposit money")
		fmt.Println("3. Withdraw money")
		fmt.Println("4. Exit")

		var choice int
		fmt.Println("Enter your choice:")
		fmt.Scanln(&choice)

		// wantsCheckBalance := choice == 1

		switch choice {
		case 1:
			fmt.Println("Your balance is:", accountBalance)

		case 2:
			var depositAmount float64
			fmt.Println("Enter the amount to deposit:")
			fmt.Scanln(&depositAmount)
			if depositAmount <= 0 {
				fmt.Println("Please Deposit amount greater than 0")
				continue
			}
			accountBalance += depositAmount
			fmt.Println("Your updated balance is:", accountBalance)
			writeBalanceToFile(accountBalance)

		case 3:
			var withdrawAmount float64
			fmt.Println("Enter the amount to withdraw:")
			fmt.Scanln(&withdrawAmount)
			if withdrawAmount <= 0 || withdrawAmount > accountBalance {
				fmt.Println("Please withdraw amount greater than 0 and less than or equal to your balance")
				continue
			} else {
				accountBalance -= withdrawAmount
				fmt.Println("Your updated balance is:", accountBalance)
				writeBalanceToFile(accountBalance)
			}

		case 4:
			fmt.Println("Thank you for using the Bank!")
			return
		default:
			fmt.Println("Invalid choice!")

		}
	}
}


* here if you want to exit the application when file is not present then use return.

if err != nil {
		fmt.Println("ERROR:", err)
		fmt.Println("Creating a new file with default balance of 1000")
        fmt.println("#######################################################")
        return
	}

* there is another way to exit the application when file is not present use panic instead of return    

if err != nil {
		fmt.Println("ERROR:", err)
		fmt.Println("Creating a new file with default balance of 1000")
        fmt.println("#######################################################")
        panic("existing the application")
	}

Example:
 
   * validate userinput and throw error when userinput to 0 and less than 0.
   * write the result to file.

package main

import (
	"fmt"
	"os"
	"errors"
)

func calculateEarnings(revenue, expenses, taxRate float64) (float64, float64) {
	earningsBeforeTax := revenue - expenses
	earningsAfterTax := earningsBeforeTax * (1 - taxRate/100)
	return earningsBeforeTax, earningsAfterTax
}

func userInputText(text string) (float64,error) {
    var userInput float64

 	fmt.Println(text)
	fmt.Scan(&userInput)

	if userInput <= 0 {
		return 0, errors.New("input must be greater than zero")
	}
	
	return userInput, nil
}

func writingEBTTOFile(earningsBeforeTax, earningsAfterTax float64) {
	data := fmt.Sprintf("Earnings Before Tax: %.2f\nEarnings After Tax: %.2f\n", earningsBeforeTax, earningsAfterTax)
	err := os.WriteFile("balance.txt", []byte(data), 0644)
	if err != nil {
		fmt.Println("Error writing to file:", err)
		return
	}
}

func main() {

	revenue, err1 := userInputText("Enter the revenue:")

	// if err != nil {
	// 	fmt.Println("Error:", err)
	// 	return
	// }
	expenses, err2 := userInputText("Enter the expenses:")

	// if err != nil {
	// 	fmt.Println("Error:", err)
	// 	return
	// }
	taxRate, err3 := userInputText("Enter the tax rate (as decimal):")

	if err1 != nil || err2 != nil || err3 != nil{
		fmt.Println("Error:", err1)
		return
	}


	earningsBeforeTax, earningsAfterTax := calculateEarnings(revenue, expenses, taxRate)
	writingEBTTOFile(earningsBeforeTax, earningsAfterTax)

}


4. reading strings from a file:

Example:

func readDataFromFile() ([]string, error) {
	file, err := os.Open("prices.txt")

	if err != nil {
		return nil, errors.New("could not open file")
	}

	scanner := bufio.NewScanner(file)

	var lines []string

	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}

	err = scanner.Err()

	if err != nil {
		file.Close()
		return nil, errors.New("reading content from file failed")
	}
 return lines, nil
}



Packages:
		 Things to keep in mind while working with packages.

		 * go mod tidy: This command cleans up your go.mod and go.sum files by removing unnecessary dependencies
		 			    and adding any that are missing.

		 * go get: Use go get to add new dependencies to your project. For example, 
		 		   go get github.com/gin-gonic/gin will add the Gin web framework.

		 * Go package names should be in lowercase and, if necessary, split into multiple words using
		   underscores (_) or camel case.

		 * Exported Names: In Go, any identifier that starts with an uppercase letter is exported and can be 
		 				   accessed from other packages. If it's lowercase, it's unexported and private to the
						   package.		

		 * Use Unexported Fields and Methods: If a field or method is not intended to be accessed outside the
		 									  package, it should be unexported (start with a lowercase letter).

		 * if you want to import third party packages into the application then 

		       -> first use: go get package-name i.e it will download that package and made available in the application.
			                 also add this dependency in go.mod file.

			   -> import in the code and use it.



Pointers:
          variables that stores the value addresses instead of value.

		  * in pointers, you can not perform calculate operations. if you want to perform then you need to use
		    Dereferencing(using *)

		  Example:

		  age := 20  then in the computer memory 20 is stored and assigned with some addess(g578dhuid)
		  and then if you want to get that value, you need to use this. getData := &age.
		  here getData contains the value address(g578dhuid) not the value. This is called pointers.

		  * Imagine a pointer as a street address. The street address points to where a house (or data) is
		    located, but it doesn’t hold the actual house (or data) itself.

		  * In Go, variables usually hold data like numbers or strings. But sometimes, you might want to work
		    with the address of that data, instead of the data itself. This is where pointers come in.


Advantage of using Pointers:

  * Avoid unnecessary value copies: By default, Go creates a copy when passing values to a functions.
    with pointers, only one value is stored in memory(and the address is passed around).

	  Example:
	            package main

				import "fmt"

				func main() {

					age := 26

					fmt.Println("Age is", age)

					adultYears = getAdultYears(age)
					fmt.Println(adultYears)

				}

				func getAdultYears(age int) int {
					return age - 18
				}

				Here the age is used multiple times then it creates the multiple copies of it. value address
				of variable age is different to the getAdultYears age. The memory address of age is different
				but value is same.


This can be overcome using pointers:

Using '&', we can store the address ov value in a variable without making copy of it.
and using '*', we can get the actual value of the variable.

Example:

package main

import "fmt"

func main() {

	age := 26

	newAge := &age

	fmt.Println("Age:", newAge)  # here we will get the memory address of the variable age
}


package main

import "fmt"

func main() {

	age := 26

	newAge := &age

	fmt.Println("Age:", *newAge)  # here we will get the actual value of the variable age. This is called Dereferencing
}


A Pointer's Null Value:

   * All values in Go have a so-called "Null Value" - i.e., the value that's set as a default if no value is
     assigned to a variable.

   * For example, the null value of an int variable is 0. Of a float64, it would be 0.0. Of a string, it's "".

   * For a pointer, it's nil - a special value built-into Go.

   * nil represents the absence of an address value - i.e., a pointer pointing at no address / no value in memory.




Struct datatype:

	* a struct is a custom data type that allows you to group together different types of variables (fields) 
	  under a single name.

problems without structs:

	* Managing related data in Go becomes messy and error-prone, requiring multiple individual variables for 
	  each piece of data. This leads to increased risk of mistakes, poor organization, and difficulty in 
	  scaling. Structs group related data together, making code cleaner, easier to maintain, and 
	  less error-prone.

Example:

package main

import "fmt"

func main() {

	firstName := getUserData("Enter your first name:")
	lastName := getUserData("Enter your last name:")
	dateOfBirth := getUserData("Enter your date of birth:")

	outputUserData(firstName, lastName, dateOfBirth)

}

func outputUserData(firstName, lastName, dateOfBirth string) {
	fmt.Println(firstName, lastName, dateOfBirth)
}

func getUserData(value string) string {

	var userData string

	fmt.Println(value)
	fmt.Scanln(&userData)

	return userData
}


using structs:

package main

import "fmt"

func main() {

	firstName := getUserData("Enter your first name:")
	lastName := getUserData("Enter your last name:")
	dateOfBirth := getUserData("Enter your date of birth:")

	appUser := User{   // struct literal notation 
		firstName: firstName,
		lastName: lastName,
		dateOfBirth: dateOfBirth,
	}

	// appUser := User{   // alternative to above, but be careful with the order of the fields 
	// 	 firstName,
	//      lastName,
	//      dateOfBirth,
	// }

	outputUserData(appUser)

	
}

type User struct {  // creating a struct
	firstName string
	lastName  string
	dateOfBirth string
}

	func outputUserData(user User) {
	fmt.Println(user.firstName, user.lastName, user.dateOfBirth)
}

func getUserData(value string) string {
    
	var userData string
    fmt.Println(value)
	fmt.Scanln(&userData)
  return userData
}


Methods:

	* methods are functions that are associated with a specific type, like a struct. You define a method by 
	  specifying a receiver (the type the method is associated with) before the function name.

	  syntax:
	  func (receiver type) methodName(parameters) returnType {  # here receiver(some name) type(struct)
         // Method body
      }

Example:

package main

import "fmt"

func main() {

	firstName := getUserData("Enter your first name:")
	lastName := getUserData("Enter your last name:")
	dateOfBirth := getUserData("Enter your date of birth:")

	appUser := User{   // struct literal notation 
		firstName: firstName,
		lastName: lastName,
		dateOfBirth: dateOfBirth,
	}

	appUser.outputUserData() // calling the method of the struct

	
}

type User struct {  // creating a struct
	firstName string
	lastName  string
	dateOfBirth string
}

func (user User) outputUserData() {   // method of the struct
   fmt.Println(user.firstName, user.lastName, user.dateOfBirth)
}

func getUserData(value string) string {
    
	var userData string
    fmt.Println(value)
	fmt.Scanln(&userData)
  return userData
}	


constructor in functions:

	* constructor function helps in creating a new instance of a struct and setting up its fields in a 
	  controlled way, ensuring that the struct is initialized correctly.

Example:

package main

import "fmt"

func main() {

	firstName := getUserData("Enter your first name:")
	lastName := getUserData("Enter your last name:")
	dateOfBirth := getUserData("Enter your date of birth:")

	appUser := newUser(firstName, lastName, dateOfBirth) // calling the constructo

	appUser.outputUserData() // calling the method of the struct

	
}

func newUser(firstName, lastName, dateOfBirth string) User { // constructor
	return User{
		firstName: firstName,
		lastName: lastName,
		dateOfBirth: dateOfBirth,
	}
}

type User struct {  // creating a struct
	firstName string
	lastName  string
	dateOfBirth string
}

func (user User) outputUserData() {   // method of the struct
   fmt.Println(user.firstName, user.lastName, user.dateOfBirth)
}

func getUserData(value string) string {
    
	var userData string
    fmt.Println(value)
	fmt.Scanln(&userData)
  return userData
}


using constructor function for validation:

here it will validate the fields, if the fields are empty then it should throw the error.

Example:

package main

import (
	"errors"
	"fmt"
)

func main() {

	firstName := getUserData("Enter your first name:")
	lastName := getUserData("Enter your last name:")
	dateOfBirth := getUserData("Enter your date of birth:")

	appUser, err := newUser(firstName, lastName, dateOfBirth) // calling the constructo

	if err != nil {
		fmt.Println(err)
		return
	}

	appUser.outputUserData() // calling the method of the struct

}

func newUser(firstName, lastName, dateOfBirth string) (User, error) { // constructor
	if firstName == "" || lastName == "" || dateOfBirth == "" {
		return User{}, errors.New("first name, last name and date of birth are required")
	}
	return User{
		firstName:   firstName,
		lastName:    lastName,
		dateOfBirth: dateOfBirth,
	}, nil
}

type User struct { // creating a struct
	firstName   string
	lastName    string
	dateOfBirth string
}

func (user User) outputUserData() { // method of the struct
	fmt.Println(user.firstName, user.lastName, user.dateOfBirth)
}

func getUserData(value string) string {

	var userData string
	fmt.Println(value)
	fmt.Scanln(&userData)
	return userData
}


NOTE:

	* while exporting functions, methods and variables inorder to access these then these names should 
	  starts with Uppercase only. if you use lowercase then those are not exported. they can only 
	  access in the same package.


Struct Embeddding:

	* struct embedding allows one struct to "embed" another struct, essentially allowing a struct to inherit 
	  the fields and methods of another. This is a way to achieve composition instead of inheritance 
	  (which Go doesn't have). It's a powerful feature because it enables you to reuse and extend existing
	   structs without having to explicitly define everything in the new struct.

Example:

package main

import (
	"errors"
	"fmt"
)

func main() {

	firstName := getUserData("Enter your first name:")
	lastName := getUserData("Enter your last name:")
	dateOfBirth := getUserData("Enter your date of birth:")
	email := getUserData("Enter your email:")
	address := getUserData("Enter your address:")

	appUser, err := NewAdmin(email, address, firstName, lastName, dateOfBirth) // calling the constructor

	if err != nil {
		fmt.Println(err)
		return
	}

	appUser.outputUserData() // calling the method of the struct

}

func NewUser(firstName, lastName, dateOfBirth string) (User, error) { // constructor
	if firstName == "" || lastName == "" || dateOfBirth == "" {
		return User{}, errors.New("first name, last name and date of birth are required")
	}
	return User{
		firstName:   firstName,
		lastName:    lastName,
		dateOfBirth: dateOfBirth,
	}, nil
}

func NewAdmin(email, address, firstName, lastName, dateOfBirth string) (Admin, error) { // constructor
	if email == "" || address == "" {
		return Admin{}, errors.New("email and address are required")
	}
	return Admin{
		email:   email,
		address: address,
		User: User{
			firstName:   firstName,
			lastName:    lastName,
			dateOfBirth: dateOfBirth,
		},
	}, nil
}

type User struct { // creating a struct
	firstName   string
	lastName    string
	dateOfBirth string
}

type Admin struct {
	email   string
	address string
	User
}

func (user User) outputUserData() { // method of the struct
	fmt.Println(user.firstName, user.lastName, user.dateOfBirth)
}

func getUserData(value string) string {

	var userData string
	fmt.Println(value)
	fmt.Scanln(&userData)
	return userData
}


NOTE:

  * using Scan, we cannot give long text as input.
  * this can overcome using bufio 

Example:

func getUserInput(prompt string) string {
	
	fmt.Println(prompt)
	
	reader := bufio.NewReader(os.Stdin) // Create a new reader
	text, err := reader.ReadString('\n') // Read user input until newline

	if err != nil {
		fmt.Println("Error reading input:", err)
		return ""
	}

	text = strings.TrimSuffix(text,"\n") // Remove any leading/trailing whitespace
	text = strings.TrimSuffix(text,"\r") // Remove any leading/trailing whitespace


	return text
}

Struct Tags:

	* struct tags are special annotations that can be added to the fields of a struct to provide additional 
	  information. They are commonly used to define metadata for things like JSON serialization, database
	  interactions, or validation.

Example:

type Note struct {
	Title     string `json:"title"`
	Content   string  `json:"content"`
	CreatedAt time.Time `json:"created_at"`
}


Interfaces:

	* interfaces are a powerful feature that allows you to define behavior in a flexible and abstract way. 
	  They provide a way to specify the methods that a type should implement, without defining how the methods
	  should be implemented. An interface type is defined by a set of method signatures, and a type is said to
	  implement an interface if it provides concrete implementations for those methods.

	  syntax:  type Speaker interface {
					Speak() string
				}

    * when interface has only one method then name of the interface should be the method name with 'er'	at the end.
	  This is only best practice.

Empty Interface: 

	* The empty interface (interface{}) is a special case. It doesn’t require any methods to be implemented, 
	  so all types in Go implicitly implement the empty interface. It’s often used when you don’t know or
	  care about the type and need to work with a generic value.   


Arrays:

	* An array is a fixed-size collection of elements of the same type. The size of an array must be specified
	  at the time of creation, and it cannot be changed afterward.

	  syntax:  prices(name) := [4]float64{12.3, 10.4,20.5,32.4}   // declaring and initializing an array
	  			                size type  values

								or

			    var productNames [4]string   // declaring an array		

				var productNames [4]string = [4]string{"raju","sandy","example","com"}

Example:

package main

import (
	"fmt"
)

func main() {

	var productNames [4]string = [4]string{"raju","sandy","example","com"}

	fmt.Println(productNames)

}	

  * if you want to access specific element in a array then you can use indexing.

      fmt.Println(productNames[1])

  * you can add the elements to array, if the size is empty 

    Example:

	package main

	import (
		"fmt"
	)

	func main() {

		var productNames [4]string = [4]string{"raju","sandy","example"}

		fmt.Println(productNames)
		fmt.Println(productNames[1])

		productNames[3] = "movie"  # updating an array and we cannot update the productnames with more product because array size is fixed.
		fmt.Println(productNames)

	}	


Arrays with slices:

	* if you want some part of the array then you can use slices.

	Example:

	package main

	import (
		"fmt"
	)

	func main() {

		var productNames [4]string = [4]string{"soap","shampoo","mobile","laptop"}

		fmt.Println(productNames)

		newProducts := productNames[1:3]  // here 1 is starting index and 3 in n-1 index(3-1 = 2)
		
		fmt.Println(newProducts)

	}

	* you can also do like this:

	    -> newProducts := productNames[1:]  // this will print all the values that starts from index 1

		-> newProducts := productNames[:3]  // this will print all the values upto 3-1 index

	* in go, it does not support the negative indexing. i.e  newProducts := productNames[-1:]		

    * it does not support higher index values than it is present i.e if the array last index is 4 and when you give
	  last index of 6 then it will throw an error.

	* by using the len function, you can check the size of an array. i.e fmt.Println(len(newProducts))  


Dynamic Array with Slices:

	*  a dynamic array is typically implemented using slices. Unlike arrays, which have a fixed size defined 
	   at the time of creation, slices are dynamic and can grow or shrink in size as needed.

	* Appending: Use append(slice, value) to add elements dynamically to a slice. Remember that append returns 
	             a new slice.

	Example:

	package main

	import (
		"fmt"
	)

	func main() {

		productNames := []string{"soap","shampoo"}

		fmt.Println(productNames)

		productNames = append(productNames,"laptop")
		
		fmt.Println(productNames)

	}



Maps:

	* maps are unordered collections of key-value pairs, where each key is unique.

	Characteristics of Maps:

	 * Unordered: The order of elements in a map is not guaranteed to be consistent.

	 * Keys are unique: Each key in a map must be unique. If you try to insert a duplicate key, it will
	                    overwrite the existing value associated with that key.

	 * Efficient lookups: Maps are implemented as hash tables, making them efficient for key-based lookups.

	 syntax: map_name := map[key_type]value_type{}	

	 Example:

	package main

	import (
		"fmt"
	)

	func main() {

		websites := map[string]string{
			"Google":    "https://www.google.com",
			"Facebook":  "https://www.facebook.com",
		}

		fmt.Println(websites)
	}	

	* if you want to extract single value from a map then use this:

	  	-> 	fmt.Println(websites["Google"])		

	* adding new key to the map

	 	-> websites["LinkedIn"] = "https://www.linkedin.com"	

	* you can also delete the key from a map

		-> delete(websites, "Facebook")


difference between maps and structs:

	* Maps: An unordered collection of key-value pairs, used for fast lookups by key. Keys must be unique,
		    and elements can be added, updated, or removed dynamically.

	* Structs: A composite data type that groups fields (which can have different types) under one name. 
			   Fields are accessed via names, and they are used to represent complex objects or records.


make function:

	* The make function is used to create and initialize built-in data structures such as slices, maps, and
	  channels. The make function allocates memory and returns a reference to the data structure.

	  syntax: make(Type, length, capacity)  // here length is the number of elements and capacity is the maximum number of elements that can be stored in the slice without allocation new memory

	  Example: using slices

	    package main

		import (
			"fmt"
		)

		func main() {

			websites := make([]string, 2, 5)
			websites[0] = "https://www.google.com"
			websites[1] = "https://www.facebook.com"


			websites = append(websites, "https://www.twitter.com")
			websites = append(websites, "https://www.instagram.com")
			websites = append(websites, "https://www.linkedin.com")

			fmt.Println(websites)
		}

		Example: using maps

		package main

		import (
			"fmt"
		)

		func main() {

			websites := make(map[string]string,3) // here 3 is capacity i.e without allocation new memory
		
			websites["Google"] = "https://www.google.com"
			websites["Facebook"] = "https://www.facebook.com"
			
			fmt.Println(websites)
		}


Type Aliasing:

	* type aliasing is a way to create a new name for an existing type, without creating a new distinct type.
	  It allows you to refer to an existing type using a different name, which can improve readability or
	  make certain types easier to manage in your code.

	  Example: type MyInt int

	            var num MyInt = 200

				

for loop for slices or arrays:
							  for printing all the values individually.
Example:

package main

import (
	"fmt"
)

func main() {

	websites := make([]string, 2, 5)
	websites[0] = "https://www.google.com"
	websites[1] = "https://www.facebook.com"

	websites = append(websites, "https://www.twitter.com")
	websites = append(websites, "https://www.instagram.com")
	websites = append(websites, "https://www.linkedin.com")
	websites = append(websites, "https://www.github.com")

	for index, value := range websites {
		fmt.Println(index,":", value)
	}
}



for loop for maps:

Example:

package main

import (
	"fmt"
)

func main() {

	websites := make(map[string]string,2) // create a map
   
	websites["LinkedIn"] = "https://linkedin.com"

	websites["Google"] = "https://www.google.com"
	websites["Facebook"] = "https://www.facebook.com"
	
	for key, value := range websites {
		fmt.Println(key, ":", value)
	}
}



Concurrency:
	    Concurrency means your program can do multiple things at the same time  i.e for running tasks parallely.

Goroutines:
            * Goroutines are Go's way of running functions concurrently (at the same time or overlapping time).
              You just add the go keyword before a function call, and Go takes care of the rest.

            * A goroutine is like a small worker that runs a function in the background.

		    * Add go before a function to run it at the same time as other code.

			* They’re super light—Go can run thousands of them

            Example:   here it will not present output to the console

			package main

			import (
				"fmt"
			)

			func main() {

			go greet("raju")
			go greet2("sandy")

			}

			func greet(str string) {
				fmt.Println("Hello", str)
			}

			func greet2(str string) {
				fmt.Println("Hi", str)
			}


Channel:
        A channel is a way for goroutines to communicate with each other — like a pipe where one goroutine
		can send data and another can receive it. i.e Communicate between goroutines

		syntax: done(variable_name) := make(chan type)  # type is int,float64, string, struct etc.

		Example:
		         * One writes a message and puts it in a mailbox 
				 * The other reads that message from the mailbox 

				 That mailbox is the channel.


Example: here it will print output to the console.

package main

import (
	"fmt"
)

func main() {

	done := make(chan bool)
	go greet("raju", done)
	go greet2("sandy", done)

	<- done

}

func greet(str string, doneChan chan bool) {
	fmt.Println("Hello", str)
	doneChan <- true  # sending data to it.
}

func greet2(str string, doneChan chan bool) {
	fmt.Println("Hi", str)
	doneChan <- true   # sending data to it.
}

* here we are sending multiple data through one channel. we can also send one data to one channel that is also possible.

* when sending multiple data to the one channel, here we are receiving odd data like sometimes we will get all time and 
  sometimes we will get only one data. here data is inconsistent because if one data is received then it is printing 
  data to the console. 

* if you don't want that, you can call this "<- done", how many times that all data is present. in above example
  we are using two function then call this 2 times. you will get all the data.

* here we are calling this <- done multiple times, which is not good because in future if you added new function
  then again we need to call it. alternatively we can use for loop for it.

 Example:

 package main

import (
	"fmt"
)

func main() {

	done := make(chan bool)
	go greet("raju", done)
	go greet2("sandy", done)

	for range done {
		
	}

}

func greet(str string, doneChan chan bool) {
	fmt.Println("Hello", str)
	doneChan <- true
}

func greet2(str string, doneChan chan bool) {
	fmt.Println("Hi", str)
	doneChan <- true
}  

* it will print all the values but after printing the values we will also get error stated below because for loop
  don't know when to stop the loop.

error:
Hi sandy
Hello raju
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
main.main()
        /Users/sriraju/Desktop/ansible/GO_Practice/app.go:13 +0xc0
exit status 2

* to overcome this error, we need to close the channel in the function after the data is sent.

Example:

package main

import (
	"fmt"
)

func main() {

	done := make(chan bool)
	go greet("raju", done)
	go greet2("sandy", done)

	for range done {

	}

}

func greet(str string, doneChan chan bool) {
	fmt.Println("Hello", str)
	doneChan <- true
	
}

func greet2(str string, doneChan chan bool) {
	fmt.Println("Hi", str)
	doneChan <- true
	close(doneChan)
}


NOTE:
while writing the file handling, when you open the file then you need to close that file. for that we need to
close the file when there is an error and also we need to close the file when job is done. here we need to
close the file 2 times. instead of that we can use defer file.Close() once.   


we started sending SQL commands to the SQLite database.

And we did this by following different approaches:

DB.Exec() (when we created the tables)

Prepare() + stmt.Exec() (when we inserted data into the database)

DB.Query() (when we fetched data from the database)

Using Prepare() is 100% optional! You could send all your commands directly via Exec() or Query().

The difference between those two methods then just is whether you're fetching data from the database (=> use Query()) or your manipulating the database / data in the database (=> use Exec()).

But what's the advantage of using Prepare()?

Prepare() prepares a SQL statement - this can lead to better performance if the same statement is executed multiple times (potentially with different data for its placeholders).

This is only true, if the prepared statement is not closed (stmt.Close()) in between those executions. In that case, there wouldn't be any advantages.

And, indeed, in this application, we are calling stmt.Close() directly after calling stmt.Exec(). So here, it really wouldn't matter which approach you're using.
